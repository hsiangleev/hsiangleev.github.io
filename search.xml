<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[git常用命令]]></title>
    <url>%2F2020%2F01%2F14%2Fgit%2Fgit%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[常用命令123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172git init # git初始化git add 1.js # 添加文件到暂存区git add . # 添加当前文件夹的所有文件到暂存区git commit -m "..." # 提交到分支git commit -a -m "..." # 从工作区直接提交，跳过暂存区git commit --amend # 合并上次的提交，即如果提交内容少了，可以用此追加提交git rm a.txt # 从暂存区移除文件，并把工作区文件一并删除git rm --cached a.txt # 从暂存区移除文件，不删除本地文件git clone [url] # 克隆现有项目git push [pb] master # 推送到远程库pb的master分支git push -f [pb] master # 强制推送到远程库pb的master分支git pull [pb] master # 从远程库获取并合并到本地分支# 当前版本库状态git status -s ?? # 尚未添加到暂存区 _M # 工作区文件修改(_表示空格) M_ # 暂存区文件修改 A_ # 新添加到暂存区 _D # 工作区文件删除 _R # 工作区文件重命名git mv a.txt b.txt # 暂存区和工作区文件重命名(相当于以下三条命令) mv a.txt b.txt git rm a.txt git add b.txt# 查看提交历史git log git log -p # 显示每次提交的差异git log -2 # 仅显示最近两次提交git log --stat # 显示文件提交信息git log --pretty= # 格式化显示信息 oneline # 单行显示 short full fuller format:"%h - $an, %ar : %s" %H # commit完整哈希值 %h # commit简短哈希值 %an # 作者名字 %ae # 作者邮箱 %ad # 作者修订日期 %ar # 作者修订日期，按多久之前显示 %cn # 提交者名字 %ce # 提交者邮箱 %cd # 提交者提交日期 %cr # 提交者提交日期，按多久之前显示 %s # 提交说明git log --graph # 显示 ASCII 图形表示的分支合并历史git log --since=2.weeks # 从什么日期(1.years1.days5.minutes 2019-01-12)git log --until # 到什么日期git log -S "aaa" # 查找某次提交记录添加或删除某些字符串的记录git log [path] # 查看某个文件或文件夹的提交记录git log --author= # 仅显示指定作者相关的提交# 版本重置git reset（设工作区为A，暂存区为B，分支为C） git reset --soft [HEAD] # 移动分支HEAD到指定位置，不取消暂存（撤销commit命令），只修改C git reset [HEAD] # 移动分支HEAD到指定位置，并取消暂存（撤销commit命令和add命令），修改B和C git reset --hard [HEAD] # 移动分支HEAD到指定位置，取消暂存，并撤销本地文件的修改，修改ABC（不安全，可能会丢失版本） git reset [file] # 取消某个文件暂存（与 git add 相反） git reset [HEAD] [file] # 某个文件暂存区重置到指定位置，只修改B（相当于A先重置，再add到B，A再恢复）git checkout -- [file] # 撤销文件修改git reflog # 查找之前的记录# 查看当前关联的远程库git remote -v # 查看当前关联的远程库（cat .git/config）git remote add [pb] [url] # 关联远程库，pb为远程 Git 仓库简写git remote show [pb] # 查看某个远程库信息git remote rename [opb] [npb] # 改名git remote rm [pb] # 移除远程库分支123456789101112# 查看当前分支git branch [b] # 创建分支git branch -d [b] # 删除分支(未合并的分支会删除失败)git branch -D [b] # 强制删除分支git branch -v # 查看每个分支的最后一次提交git branch --merged # 查看哪些分支已经合并到当前分支git branch --no-merged # 查看所有包含未合并工作的分支# 切换分支git checkout [b] # 切换分支git checkout -b [b] # 创建并切换分支# 合并某分支到当前分支git merge [b] # 合并某分支到当前分支整合分支的修改（合并test分支到master）合并分支（git merge test）变基（提交历史可能会丢失）1234git checkout testgit rebase mastergit checkout mastergit merge test不同之处：合并分支的历史记录为并行的，变基的历史记录为串行的注意：不要对在你的仓库外有副本的分支执行变基git远程分支当从远程库克隆时，会为你自动将其命名为 origin（git clone -o [test] [url]，可以改为test），拉取它的所有数据，创建一个指向它的 master 分支的指针，并且在本地将其命名为 origin/master（跟踪分支）。Git 也会给你一个与 origin 的 master 分支在指向同一个地方的本地 master 分支。本地提交的时候master指针移动，但是origin/master指针不会移动123a=&gt;b=&gt;c=&gt;d=&gt;e # 远程分支，本地在c处克隆，远程继续提交d和e，远程master指向e处&lt;/br&gt;a=&gt;b=&gt;c # 本地origin/master指向c处，只要不与服务器连接，指针不移动&lt;/br&gt;a=&gt;b=&gt;c=&gt;f=&gt;g # 本地master分支初始指向c处，继续提交f和g，master指向g处git fetch origin: 获取本地没有的远程库origin数据，移动 origin/master 指针指向新的、更新后的位置123a=&gt;b=&gt;c=&gt;d=&gt;e # 远程分支，本地在c处克隆，远程继续提交d和e，远程master指向e处&lt;/br&gt;a=&gt;b=&gt;c=&gt;d=&gt;e # 本地origin/master指针移动到远程origin最新处，指向e&lt;/br&gt;a=&gt;b=&gt;c=&gt;f=&gt;g # 本地master分支初始指向c处，继续提交f和g，master指向g处git merge origin/master: 合并到当前分支git checkout -b newBranch origin/master: 新建分支，并指向跟踪分支的位置（跟踪分支和分支不同的是只有一个指针，不含可编辑的副本）git push origin –delete master: 删除远程分支git配置自定义服务器1234567891011121314useradd git # 管理员创建用户passwd git # 设置git用户密码su git # 切换git用户mkdir .ssh chmod 700 .sshcd .sshtouch authorized_keys # 创建保存公钥的文件chmod 600 authorized_keys # 修改权限vi authorized_keys # 把公钥写进文件（如果用户的公钥不在文件中，则每次需要输入登录密码）cd /home/git # 回到主目录git init --bare test.git # 新建空仓库# 本地测试git remote add local git@ip:/home/git/test.git # 关联远程库git push local master # 本地推送GitWeb123yum install git-instaweb # 安装git instaweb -p 3000 # 修改监听端口（先进入仓库所在目录）git instaweb --start # 启动服务]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux命令之用户与组管理]]></title>
    <url>%2F2019%2F12%2F30%2Flinux%2F%E7%94%A8%E6%88%B7%E4%B8%8E%E7%BB%84%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[用户管理useradd: 添加用户123useradd -g test -G groupA,groupB -d /home/test test # 创建一个用户，初始群组为test，并添加到群组groupA和groupB中，创建自家目录/home/test并指定登录目录，用户名为testuseradd -d /www -M test # 不创建用户自家目录，指定登录目录 /www，用户名为testuseradd -e "2019-12-30" test # 添加用户，并给用户设置有效期userdel: 删除用户12userdel test # 删除用户userdel -r test # 删除用户，并删除用户home目录passwd: 修改用户密码passwd test # 修改test用户密码usermod: 修改用户信息1234usermod -a -G groupC,groupD test # test用户添加到groupC,groupD群组，并且不离开其他群组(不加 -a 则离开其他群组)usermod -l test2 test # 修改test登录名为test2usermod -L test # 锁定用户usermod -U test # 解除锁定su user # 切换用户cat /etc/passwd # 查看所有用户users # 查看当前有哪些用户登录(w/who)组管理groupadd: 添加组groupdel: 删除组groupmems: 组成员管理1234groupmems -g groupA -l # 显示组groupA中的所有用户groupmems -g groupA -a test # 把test用户添加到groupA组中groupmems -g groupA -d test # 删除组groupA中的用户testgroupmems -g groupA -p # 删除组groupA的所有用户groupmod: 修改组groupmod groupA -n groupB # 修改组名groupA为groupBgroups: 显示用户所在的组12groups # 显示当前用户所在的组groups test # 显示test用户所在的组]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>useradd</tag>
        <tag>groupadd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[uipath studio编辑器介绍与使用]]></title>
    <url>%2F2019%2F11%2F07%2Fuipath%2Fuipath%20studio%E7%BC%96%E8%BE%91%E5%99%A8%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[打开编辑器默认为英文，可以改为中文，点击settings=&gt;general=&gt;language，选择中文简体，改完之后需要重启编辑器，但是改为中文之后里面所有的activities都会变成中文的，搜索的时候不太好搜，所以我便没有改。在start的右边new process下面的process，选择项目名称和路径就可以创建了项目了，编辑器对应的功能如下图studio官方文档，所有的活动在文档里面基本都能搜到，列举一些常用的活动：Assign: 变量赋值，例如把某个值赋给某个变量Click: 鼠标单击操作Double Click: 鼠标双击操作Type Into: input框输入Delay: 延时Send HotKey: 键盘按键Message Box: 编辑器弹窗，测试使用excel相关常用活动：Excel Application Scope: 类似一个包装，excel的相关操作都要放到这个里面，需要填写的是excel路径Read Range: 读取excel的某个表，输出的数据类型为DataTable类型For Each Row: 遍历DataTable类型的数据取值，如row(“表头”)Write Range: 数据写入excel]]></content>
      <categories>
        <category>uipath</category>
      </categories>
      <tags>
        <tag>uipath</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[uipath下载安装]]></title>
    <url>%2F2019%2F11%2F07%2Fuipath%2Fuipath%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[首先是下载软件我便下载了好久，因为我一开始进的是中文官网，中文官网和英文的好像有些区别，在中文官网点击试用的时候先选择的是社区版本，然后需要填写个人信息包括邮箱地址，软件下载方式发送到邮箱，但是我提交之后一直收不到邮箱，又试了一下企业试用版的也是一样收不到邮箱。无奈之下进入英文的网站，，点击Start Trial之后，选择Community版本发现和中文不同的地方是需要登录，然后使用office账户登录之后在这里发现下载地址，社区版下载下载完成双击安装，但是没有提示安装的路径，因为需要选择版本，我直接选择社区版，然后选择第一个先行版，然后就直接自动打开了软件，然后用win10的搜索uipath发现除了uipath studio还有一个uipath robot，到这里便安装完成了。需要注意的是这个下载下来的是64位的软件，无法安装到32位的电脑安装的时候需要联网电脑的framework版本最低为4.6.1软件默认安装到了用户目录，即C:\Users\...\AppData\Local\UiPath]]></content>
      <categories>
        <category>uipath</category>
      </categories>
      <tags>
        <tag>uipath</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三省吾身]]></title>
    <url>%2F2019%2F08%2F10%2F%E9%9A%8F%E7%AC%94%2F%E4%B8%89%E7%9C%81%E5%90%BE%E8%BA%AB%2F</url>
    <content type="text"><![CDATA[不知道自己为什么会如此恋旧，比如去菜市场买菜，如果连续几天在这家买，今天突然想去另一家了，走过这家小摊时会有一种愧疚感，不敢直视摊主。租房也是如此，与朋友合租不到一年，他走之后我却不想换房，虽然知道一个人住这么大的房子有点奢侈，虽然房间连空调也没有，如果换一个房子的话完全可以租个小点的设施齐全的并且租金也会便宜点，可是终究下不了换的决心，或许也只是因为习惯吧。一个人久了会上瘾，虽然心里也会想着需要谈恋爱了，遇到心怡的人也有想撩她的想法，但是每次想到自己是素食者，想到自己挑食如此严重，吃个饭都是件麻烦事也就打消了念头。也曾想过改变，可是恶心反胃之情溢于言表，想想自己终究也只是普通人吧，连吃饭都不能逼迫自己一把。人际交往最难，遇到不熟的人可以直接走过不打招呼，遇到很熟悉的人可以追上去喊他，但最怕遇到半熟不熟的人，打招呼也不是，不打招呼也不是，分外尴尬。还有一个性格缺点便是不知道怎么保持友谊，可以一起打游戏的也还好，可以喊他打游戏顺便聊聊近况，其他的如果他不找我我也基本不找他聊，虽然知道这样很不好，但却怕打扰他，不知如何聊，终究越走越远。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js replace正则替换]]></title>
    <url>%2F2019%2F08%2F09%2Fjs%2Fjs%20replace%E6%AD%A3%E5%88%99%E6%9B%BF%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[replace() 方法返回一个由替换值替换一些或所有匹配的模式后的新字符串。模式可以是一个字符串或者一个正则表达式，替换值可以是一个字符串或者一个每次匹配都要调用的回调函数。1. 当第二个参数是字符串时，可以使用特殊变量名变量名代表的值$$插入一个 “$”$&amp;插入匹配的子串$`插入当前匹配的子串左边的内容$’插入当前匹配的子串右边的内容$n假如第一个参数是 RegExp对象，并且 n 是个小于100的非负整数，那么插入第 n 个括号匹配的字符串示例：1234567891011var str="123&#123;&#123;name&#125;&#125;456";// $$值为$// 当前正则匹配到的值为 &#123;&#123;name&#125;&#125; ，即$&amp;值为&#123;&#123;name&#125;&#125;// 第一个括号$1匹配的字符串为 &#123;&#123; ，第二个括号$2匹配的字符串为 &#125;&#125;// 匹配的字符串左侧的内容为 123，即$`值为123// 匹配的字符串右侧的值为 456 ，即$'值为456str.replace(/(\&#123;\&#123;)\w+(\&#125;\&#125;)/,"$1code$2"); // 123&#123;&#123;code&#125;&#125;456str.replace(/(\&#123;\&#123;)\w+(\&#125;\&#125;)/,"$1co$$de$2"); // 123&#123;&#123;co$de&#125;&#125;456str.replace(/(\&#123;\&#123;)\w+(\&#125;\&#125;)/,"$1co$&amp;de$2"); // 123&#123;&#123;co&#123;&#123;name&#125;&#125;de&#125;&#125;456str.replace(/(\&#123;\&#123;)\w+(\&#125;\&#125;)/,"$1co$`de$2"); // 123&#123;&#123;co123de&#125;&#125;456str.replace(/(\&#123;\&#123;)\w+(\&#125;\&#125;)/,"$1co$'de$2"); // 123&#123;&#123;co456de&#125;&#125;4562. 第二个参数也可以使用函数，函数的参数含义为：变量名代表的值match匹配的子串。（对应于上述的$&amp;。）p1,p2,…假如replace()方法的第一个参数是一个RegExp 对象，则代表第n个括号匹配的字符串。（对应于上述的$1，$2等。）offset匹配到的子字符串在原字符串中的偏移量（即匹配的第一个字符在原字符串的索引）。string被匹配的原字符串。示例：123456789var str="123&#123;&#123;name&#125;&#125;456";var s=str.replace(/(\&#123;\&#123;\s*)\w+(\s*\&#125;\&#125;)/, function(match,s1,s2,offset,string) &#123; console.log(match) // &#123;&#123;name&#125;&#125; console.log(s1) // &#123;&#123; console.log(s2) // &#125;&#125; console.log(offset) // 3 console.log(string) // 123&#123;&#123;name&#125;&#125;456 return s1+"code"+s2&#125;) // 123&#123;&#123;code&#125;&#125;456]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js十大排序算法记录]]></title>
    <url>%2F2019%2F07%2F10%2Fjs%2Fjs%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[冒泡排序说明：即两两比较，较大的放到后面动图演示：js代码：1234567891011121314151617function bubbleSort(arr) &#123; var len=arr.length; for(var i=0;i&lt;len;i++)&#123; // len-1是因为前一项为j，后一项为j+1 // -i是因为每次第一次循环结束之后，倒数第i项便已经排好了 for(var j=0;j&lt;len-1-i;j++)&#123; // 判断如果前面的比后面的大，则交换位置 if(arr[j]&gt;arr[j+1])&#123; // 交换第j项与第j+1项 var temp=arr[j]; arr[j]=arr[j+1]; arr[j+1]=temp; &#125; &#125; &#125; return arr;&#125;选择排序说明：即假设当前位置为最小项，如果后面找到比它小的，则记录当前项索引，里层循环结束后交换，交换当前项和最小项动图演示：js代码：12345678910111213141516171819function selectionSort(arr) &#123; var minIndex,len=arr.length; for(var i=0;i&lt;len;i++)&#123; minIndex=i; // 假设当前位置为最小项 for(var j=i+1;j&lt;len;j++)&#123; // 判断后面的是否有比它小的，如果有，则记录 if(arr[minIndex]&gt;arr[j])&#123; minIndex=j; &#125; &#125; // 如果当前项不是最小，则交换 if(i!==minIndex)&#123; var temp=arr[i]; arr[i]=arr[minIndex]; arr[minIndex]=temp; &#125; &#125; return arr;&#125;插入排序说明：类似玩扑克牌，假设从第二项开始都是未排列的，在已排序序列中从后向前扫描，找到相应位置插入（对应几乎快排好的数据效率高）。动图演示：js代码：12345678910111213141516171819202122function insertSort(arr) &#123; var len=arr.length; for(var i=1;i&lt;len;i++)&#123; var temp=arr[i]; // 待排序的项 // 向前搜索，如果满足当前项大于待排项，则把当前项赋值给下一项， for(var j=i-1;j&gt;=0&amp;&amp;arr[j]&gt;temp;j--)&#123; arr[j+1] = arr[j]; &#125; // 把待排序项赋值到最后一个满足条件的项 arr[j+1] = temp; // while写法，与上面的for循环等价 // var preIndex=i-1; // var current=arr[i]; // while(preIndex&gt;=0 &amp;&amp; arr[preIndex]&gt;current)&#123; // arr[preIndex+1]=arr[preIndex]; // preIndex--; // &#125; // arr[preIndex+1]=current; &#125; return arr;&#125;希尔排序说明：插入排序改进版，即先把数据分为若干子数列进行排序，待序列基本有序时，再整体进行插入排序动图演示：js代码：123456789101112131415161718function insertSort(arr) &#123; var len=arr.length; var step=1; while(step &lt; len/3) &#123; //定义间隔序列，确保最后一次间隔为1，即最后一次整体进行插入排序 step =step*3+1; &#125; for(step;step&gt;0;step=Math.floor(step/3))&#123; // 里层与插入排序基本一样 for(var i=step;i&lt;len;i++)&#123; var temp=arr[i]; for(var j=i-step;j&gt;=0&amp;&amp;arr[j]&gt;temp;j-=step)&#123; arr[j+step]=arr[j]; &#125; arr[j+step]=temp; &#125; &#125; return arr;&#125;归并排序说明：采用分治法，即一分二，二分四，分到最后的小数组只有一个元素，或没有元素，然后两两比较动图演示：js代码：123456789101112131415161718192021222324252627function mergeSort(arr) &#123; var len=arr.length; // left和right分割到最小为只有一个元素的数组 if(len&lt;2)&#123; return arr; &#125; // 找中间值，根据中间值把数组分为更小的两个数组 var middle=Math.floor(len/2); var left=arr.slice(0,middle); var right=arr.slice(middle); return merge(mergeSort(left), mergeSort(right));&#125;function merge(left, right) &#123; // left和right为已排序的数组 var result=[]; while(left.length &amp;&amp; right.length)&#123; if(left[0]&gt;right[0])&#123; result.push(right.shift()); &#125;else&#123; result.push(left.shift()); &#125; &#125; while(left.length) result.push(left.shift()); while(right.length) result.push(right.shift()); return result;&#125;快速排序说明：设置基准项，把所有比基准大的排后面，比基准小的排前面，然后把前面的数组和后面的数组再重复前面操作，即采用分治法，一分二，二分四…动图演示：js代码：123456789101112131415161718192021222324252627282930313233function quickSort(arr, left, right) &#123; var len = arr.length, partitionIndex, left = typeof left != 'number' ? 0 : left, right = typeof right != 'number' ? len - 1 : right; if (left &lt; right) &#123; partitionIndex = partition(arr, left, right); quickSort(arr, left, partitionIndex-1); quickSort(arr, partitionIndex+1, right); &#125; return arr;&#125;function partition(arr, left ,right) &#123; // 分区操作 var pivot = left, // 设定基准值（pivot） index = pivot + 1; for (var i = index; i &lt;= right; i++) &#123; if (arr[i] &lt; arr[pivot]) &#123; // 每次找到一个比基准大，一个比基准小的交换 if(i!==index) swap(arr, i, index); index++; &#125; &#125; // 交换基准与最后一个比基准小的，即所有比基准小的都在基准前面了 swap(arr, pivot, index - 1); return index-1;&#125;// 下文省略swap函数function swap(arr, i, j) &#123; var temp = arr[i]; arr[i] = arr[j]; arr[j] = temp;&#125;堆排序说明：是一种利用堆的概念来排序的选择排序。创建大顶堆，即每个节点大于或等于其子节点堆首尾互换，尺寸减1，调用堆调整，数组顶端数据调整到相应位置重复步骤 2，直到堆的尺寸为 1。动图演示：js代码：123456789101112131415161718192021222324252627282930313233343536var len;function buildMaxHeap(arr) &#123; // 建立大顶堆 len = arr.length; for (var i = Math.floor(len/2); i &gt;= 0; i--) &#123; heapify(arr, i); &#125;&#125;function heapify(arr, i) &#123; // 堆调整 // i为当前节点，left和right为其左右子节点 var left = 2 * i + 1, right = 2 * i + 2, largest = i; // 然后假设当前节点为最大节点，判断子节点是否比它大，把最大的节点交换到当前节点 if (left &lt; len &amp;&amp; arr[left] &gt; arr[largest]) &#123; largest = left; &#125; if (right &lt; len &amp;&amp; arr[right] &gt; arr[largest]) &#123; largest = right; &#125; if (largest != i) &#123; swap(arr, i, largest); heapify(arr, largest); &#125;&#125;function heapSort(arr) &#123; buildMaxHeap(arr); for (var i = arr.length-1; i &gt; 0; i--) &#123; swap(arr, 0, i); len--; heapify(arr, 0); &#125; return arr;&#125;本文gif图及部分代码来源https://github.com/hustcc/JS-Sorting-Algorithm]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记录以前不知道的web细节]]></title>
    <url>%2F2019%2F06%2F13%2Fjs%2F%E8%AE%B0%E5%BD%95%E4%BB%A5%E5%89%8D%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84web%E7%BB%86%E8%8A%82%2F</url>
    <content type="text"><![CDATA[移除event.preventDefault()如果一个事件中有时需要调用event.preventDefault()取消浏览器默认事件，有时又不需要调用比如自定义滚动条，当滚动条还没有滚动到最顶端或者最底端时，需要调用event.preventDefault()取消浏览器默认事件，不然会出现自定义滚动条和最外层document的滚动条同时滚动而当滚动条滚动到最顶端或者最底端时，自定义滚动条已经不能滚动了，则需要让最外层document的滚动条滚动，便需要移除event.preventDefault()解决方法便是取消当前事件的绑定，示例代码：12345678910var f=function(e) &#123; // ... // 滚动到最大最小时，重新绑定事件，相当于移除preventDefault if(that.current &gt;= that.maxCurrent || that.current &lt;= 0)&#123; that.wrapEl.off("mousewheel DOMMouseScroll", f).on("mousewheel DOMMouseScroll", f); &#125;else&#123; e.preventDefault(); &#125;&#125;this.wrapEl.on("mousewheel DOMMouseScroll", f); // 给dom添加滚动事件滚动条示例css margin百分比可以对margin设置百分比，但是是相对于父元素的宽度的百分比，示例代码：12345// div &#123;width: 400px;height: 200px;outline: 1px solid #ccc&#125;// p&#123;margin: 10%;display: inline-block;padding: 10%&#125;&lt;div&gt; &lt;p&gt;aaa&lt;/p&gt;&lt;/div&gt;设置如上则可以看到p的margin全部为40px，而不是左右40px上下20px，padding同理css line-height百分比和数字值的区别line-height设置数字值时，子元素会继承这个数字，所以子元素的line-height值为这个数字乘以子元素的font-sizeline-height设置百分比时，元素会先计算出值，即百分比乘以元素的font-size，然后把这个值继承给子元素示例：12345678910111213// div &#123;width: 400px;height: 200px;outline: 1px solid #ccc;font-size: 30px;&#125;// p&#123;margin: 0;display: inline-block;padding: 0;background: #ddd;font-size:15px;&#125;// .test1&#123;line-height: 150%;&#125;// .test2&#123;line-height: 1.5;&#125;// p的line-height为：150% * 30&lt;div class="test1"&gt; &lt;p&gt;aaa&lt;/p&gt;&lt;/div&gt;// p的line-height为：1.5 * 15&lt;div class="test2"&gt; &lt;p&gt;aaa&lt;/p&gt;&lt;/div&gt;结果如图：js判断进入当前页面的方式performance.navigation.type如果等于0，则为直接进入页面如果等于1，则是在本页面刷新进入的如果等于2，则是通过后退进入本页面的表格边框css属性border-collapse：CSS 属性是用来决定表格的边框是分开的还是合并的。separate: 分隔模式(默认)，在分隔模式下，相邻的单元格都拥有独立的边框。collapse: 合并模式，在合并模式下，相邻单元格共享边框。border-spacing：指定相邻单元格边框之间的距离（只适用于 separate分隔模式 ）。]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js自定义事件]]></title>
    <url>%2F2019%2F05%2F13%2Fjs%2Fjs%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[1. html如下：12&lt;div class="test1" lay-filter="data1"&gt;&lt;/div&gt;&lt;div class="test2" lay-filter="data2"&gt;&lt;/div&gt;2. 创建构造函数InitClass，options参数包含传过来的选择器el，render函数为生成dom，evt函数为绑定的事件1234567891011121314151617181920212223function InitClass(options) &#123; this.options=options; this.filter=document.querySelector(options.el).getAttribute("lay-filter"); this.render();&#125;InitClass.prototype.render=function() &#123; document.querySelector(this.options.el).innerHTML='&lt;input type="text"&gt;&lt;button&gt;获取&lt;/button&gt;'; this.evt();&#125;InitClass.prototype.evt=function() &#123; var that=this; var childs=document.querySelector(this.options.el).children; childs[1].onclick=function() &#123; var val=childs[0].value; // 如果input为空或不是数字，则不返回数据 if(val &amp;&amp; !isNaN(val))&#123; // testModule: 对外暴漏的变量，getNumberInp: 自定义事件名，filter: 不同的dom对象，最后一个参数为回调函数的参数，并且返回的this为当前按钮对象 InitClass.event.call(this, "testModule", 'getNumberInp('+that.filter+')', &#123; value: Number(val) &#125;); &#125; &#125;&#125;3. 添加自定义事件123456789101112131415161718192021222324252627// 事件存储的变量InitClass.config=&#123; event: &#123;&#125;&#125;InitClass.onevent=function(modName, events, callback) &#123; if (typeof modName !== 'string' || typeof callback !== 'function') return this; return InitClass.event(modName, events, null, callback);&#125;InitClass.event=function(modName, events, params, fn) &#123; var that = this ,filter = events.match(/\((.*)\)$/) || [] //提取事件过滤器字符结构，如：select(xxx) ,eventName = (modName + '.' + events).replace(filter[0], '') //获取事件名称，如：form.select ,filterName = filter[1] || ''; //获取过滤器名称,，如：xxx //添加事件 if (fn) &#123; InitClass.config.event[eventName] = InitClass.config.event[eventName] || &#123;&#125;; InitClass.config.event[eventName][filterName] = fn; return this; &#125; //执行事件回调 for(var key in InitClass.config.event[eventName])&#123; //执行指定事件 key === filterName &amp;&amp; InitClass.config.event[eventName][key].call(that, params); &#125;&#125;4. 对外暴漏的变量12345678var testModule = &#123; on: function(events, callback) &#123; return InitClass.onevent.call(this, 'testModule', events, callback); &#125;, render: function(options) &#123; new InitClass(options); &#125;&#125;5. 框架使用代码为：12345678910111213testModule.render(&#123; el: ".test1"&#125;);testModule.render(&#123; el: ".test2"&#125;);testModule.on("getNumberInp(data1)", function(d) &#123; console.log("第一个对象返回的数据："+d.value)&#125;)testModule.on("getNumberInp(data2)", function(d) &#123; console.log("第二个对象返回的数据："+d.value)&#125;)6. 执行结果：第一个input输入为数字时，点击第一个按钮，结果如下图：输入非数字，则不执行回调，如下图：第二个input输入为数字时，点击第二个按钮，结果如下图：7. 完整js代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;div class="test1" lay-filter="data1"&gt;&lt;/div&gt;&lt;div class="test2" lay-filter="data2"&gt;&lt;/div&gt;&lt;script&gt; (function(window) &#123; function InitClass(options) &#123; this.options=options; this.filter=document.querySelector(options.el).getAttribute("lay-filter"); this.render(); &#125; InitClass.prototype.render=function() &#123; document.querySelector(this.options.el).innerHTML='&lt;input type="text"&gt;&lt;button&gt;获取&lt;/button&gt;'; this.evt(); &#125; InitClass.prototype.evt=function() &#123; var that=this; var childs=document.querySelector(this.options.el).children; childs[1].onclick=function() &#123; var val=childs[0].value; if(val &amp;&amp; !isNaN(val))&#123; InitClass.event.call(this, "testModule", 'getNumberInp('+that.filter+')', &#123; value: Number(val) &#125;); &#125; &#125; &#125; InitClass.config=&#123; event: &#123;&#125; &#125; InitClass.onevent=function(modName, events, callback) &#123; if (typeof modName !== 'string' || typeof callback !== 'function') return this; return InitClass.event(modName, events, null, callback); &#125; InitClass.event=function(modName, events, params, fn) &#123; var that = this ,filter = events.match(/\((.*)\)$/) || [] //提取事件过滤器字符结构，如：select(xxx) ,eventName = (modName + '.' + events).replace(filter[0], '') //获取事件名称，如：form.select ,filterName = filter[1] || ''; //获取过滤器名称,，如：xxx //添加事件 if (fn) &#123; InitClass.config.event[eventName] = InitClass.config.event[eventName] || &#123;&#125;; InitClass.config.event[eventName][filterName] = fn; return this; &#125; //执行事件回调 for(var key in InitClass.config.event[eventName])&#123; //执行指定事件 key === filterName &amp;&amp; InitClass.config.event[eventName][key].call(that, params); &#125; &#125; var testModule = &#123; on: function(events, callback) &#123; return InitClass.onevent.call(this, 'testModule', events, callback); &#125;, render: function(options) &#123; new InitClass(options); &#125; &#125; window.testModule=testModule; &#125;)(window) // 使用 testModule.render(&#123; el: ".test1" &#125;); testModule.render(&#123; el: ".test2" &#125;); testModule.on("getNumberInp(data1)", function(d) &#123; console.log("第一个对象返回的数据："+d.value) &#125;) testModule.on("getNumberInp(data2)", function(d) &#123; console.log("第二个对象返回的数据："+d.value) &#125;)&lt;/script&gt;]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网页引入github-stars和显示fork me on github]]></title>
    <url>%2F2019%2F04%2F10%2Fgithub%2F%E5%9C%A8%E7%BD%91%E9%A1%B5%E5%BC%95%E5%85%A5github-stars%2F</url>
    <content type="text"><![CDATA[页面引入github-stars直接访问地址https://img.shields.io/github/stars/hsiangleev/layuiExtend.svg，就可以看到图标了。其中把hsiangleev/layuiExtend字段换成自己的github名和仓库名就能看到自己的仓库stars数量了，stars换成forks，可以看到forks数量。地址后面还可以添加参数控制样式颜色之类的，具体配置可以看下网站shields.io示例：网站左上角或者右上角显示fork me on github使用：123&lt;a href="https://github.com/hsiangleev/layuiExtend"&gt; &lt;img width="149" height="149" src="https://github.blog/wp-content/uploads/2008/12/forkme_right_white_ffffff.png?resize=149%2C149" class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"&gt;&lt;/a&gt;示例：更多使用可以看下GitHub Ribbons]]></content>
      <categories>
        <category>github</category>
      </categories>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[parseInt深入探索]]></title>
    <url>%2F2019%2F03%2F22%2Fjs%2FparseInt%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[今天突然看到了一个js的题目[1,2,3].map(parseInt)应该输出什么，由于对parseInt的参数只是知道个大概，没有想出这个题目的结果，然后到MDN上面看了一下parseInt的解释：parseInt(string, radix);string 要被解析的值。如果参数不是一个字符串，则将其转换为字符串(使用 ToString 抽象操作)。字符串开头的空白符将会被忽略。radix 一个介于2和36之间的整数(数学系统的基础)，表示上述字符串的基数。比如参数”10”表示使用我们通常使用的十进制数值系统。始终指定此参数可以消除阅读该代码时的困惑并且保证转换结果可预测。当未指定基数时，不同的实现会产生不同的结果，通常将值默认为10。返回解析后的整数值。 如果被解析参数的第一个字符无法被转化成数值类型，则返回 NaN。由于[1,2,3].map(function(val,index){})中的val,index分别为(1,0)(2,1)(3,2)所以[1,2,3].map(parseInt)相当于把(val,index)传入parseInt，即[parseInt(1,0),parseInt(2，1),parseInt(3，2)]当基数radix为 undefined，或者基数为 0 或者没有指定的情况下，JavaScript 作如下处理：如果字符串 string 以”0x”或者”0X”开头, 则基数是16 (16进制).如果字符串 string 以”0”开头, 基数是8（八进制）或者10（十进制），那么具体是哪个基数由实现环境决定。ECMAScript 5 规定使用10，但是并不是所有的浏览器都遵循这个规定。因此，永远都要明确给出radix参数的值。如果字符串 string 以其它任何值开头，则基数是10 (十进制)。所以parseInt(1,0)即parseInt(1,10)，结果为1。如果parseInt的字符不是指定基数中的数字，则忽略该字符和所有后续字符，并返回解析到该点的整数值。parseInt将数字截断为整数值。允许使用前导空格和尾随空格。所以在parseInt(2，1)中，2不是1进制中的数字，因为1进制只有0，parseInt(3，2)中，3不是2进制中的数字，因为2进制只有0和1，所以会忽略该字符，即返回 NaN。即该题目的结果为[1,NaN,NaN]。总结：可以这样理解，把radix进制的string转成10进制的数字，若string中的字符不在radix进制内，则忽略该字符和所有后续字符parseInt(12,6)，即把6进制的12转换成10进制，所以是8而parseInt(127,6)，由于字符7不在6进制中，所以忽略，即也是把6进制的12转换成10进制，所以也是8]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack配置react]]></title>
    <url>%2F2019%2F03%2F09%2Fjs%2Fwebpack%E9%85%8D%E7%BD%AEreact%2F</url>
    <content type="text"><![CDATA[初始化package.jsonnpm init安装babel-loader(新版8.0.0报错)cnpm install babel-loader@7.1.5 babel-preset-es2015 babel-preset-react --save-dev安装webpackcnpm install webpack webpack-cli webpack-dev-server --save-dev创建webpack.config.js1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162var path = require('path');var webpack = require('webpack');var HtmlwebpackPlugin = require('html-webpack-plugin');var ROOT_PATH = path.resolve(__dirname);var APP_PATH = path.resolve(ROOT_PATH, 'app');var BUILD_PATH = path.resolve(ROOT_PATH, 'build');module.exports= &#123; // @babel/polyfill兼容ie9,ie10 entry: ["@babel/polyfill", path.resolve(APP_PATH, 'index.jsx')], output: &#123; path: BUILD_PATH, filename: 'bundle.js' &#125;, mode: "development", // mode: "production", //enable dev source map devtool: 'eval-source-map', //enable dev server devServer: &#123; historyApiFallback: true, hot: true, inline: true, progress: true, port: 3000 &#125;, //babel重要的loader在这里 module: &#123; rules: [ &#123; test: /\.jsx?$/, loader: 'babel-loader', include: APP_PATH &#125;, &#123; test: /\.scss$/, loaders: ['style-loader', 'css-loader', 'sass-loader'] &#125;, &#123; test: /\.(png|jpg|gif|svg)$/, loader: 'file-loader', options: &#123; name: '[name].[ext]?[hash]' &#125; &#125;, &#123; test: /\.(gif|jpg|png|woff|woff2|svg|eot|ttf)\??.*$/, loader: 'url-loader?limit=50000&amp;name=[path][name].[ext]' &#125; ] &#125;, resolve: &#123; extensions: ['*', '.js', '.jsx'] &#125;, plugins: [ new HtmlwebpackPlugin(&#123; title: 'My first react app', template: "index.html", filename: "index.html", inject: true &#125;) ]&#125;npm中添加webpack启动命令123"dev": "webpack-dev-server --progress --profile --colors --hot","build": "webpack --progress --profile --colors","test": "karma start"安装React和React-Domcnpm install react react-dom --save应用中使用sasscnpm install css-loader style-loader sass-loader node-sass --save-dev创建 .babelrc文件，babel分离12345678&#123; "presets": ["react", "es2015"], "env": &#123; "development": &#123; "presets": ["react-hmre"] &#125; &#125;&#125;安装其他loadercnpm install html-webpack-plugin file-loader babel-core url-loader babel-preset-react-hmre @babel/polyfill --save-devloader汇总12345678910111213141516171819202122"devDependencies": &#123; "babel-core": "^6.26.3", "babel-loader": "^7.1.5", "babel-preset-es2015": "^6.24.1", "babel-preset-react": "^6.24.1", "babel-preset-react-hmre": "^1.1.1", "css-loader": "^1.0.0", "file-loader": "^2.0.0", "html-webpack-plugin": "^3.2.0", "node-sass": "^4.9.3", "sass-loader": "^7.1.0", "style-loader": "^0.23.0", "url-loader": "^1.1.1", "webpack": "^4.17.1", "webpack-cli": "^3.1.0", "webpack-dev-server": "^3.1.7" &#125;, "dependencies": &#123; "@babel/polyfill": "^7.2.5", "react": "^16.8.4", "react-dom": "^16.8.4" &#125;创建index.html模板页title为&lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt;body为&lt;div id=&quot;root&quot;&gt;&lt;/div&gt;创建src文件夹，src文件夹下创建index.jsx1234567import React from 'react';import ReactDOM from 'react-dom';// ...ReactDOM.render( element, document.getElementById('root'));执行命令npm run dev，浏览器打开http://localhost:3000/]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记录未留心的vue细节]]></title>
    <url>%2F2019%2F03%2F06%2Fjs%2F%E6%9C%AA%E7%95%99%E5%BF%83%E7%9A%84vue%E7%BB%86%E8%8A%82%2F</url>
    <content type="text"><![CDATA[vue模板语法v-once指令通过使用 v-once 指令，你也能执行一次性地插值，当数据改变时，插值处的内容不会更新。&lt;span v-once&gt;这个将不会改变: &lt;/span&gt;动态参数（2.6.0 新增）可以用方括号括起来的 JavaScript 表达式作为一个指令的参数，即节点属性可以动态设置&lt;a v-bind:[attributeName]=&quot;url&quot;&gt; ... &lt;/a&gt;&lt;a v-on:[eventName]=&quot;doSomething&quot;&gt; ... &lt;/a&gt;计算属性和侦听器计算属性（对于任何复杂逻辑，都应当使用计算属性）如果计算属性的依赖属性发生改变，则计算属性也会相应改变计算属性是基于它们的依赖进行缓存的，只在相关依赖发生改变时它们才会重新求值条件渲染在 template 元素上使用 v-if 条件渲染分组，而不需要多加一层div因为 v-if 是一个指令，所以必须将它添加到一个元素上。但是如果想切换多个元素，此时可以把一个 template 元素当做不可见的包裹元素，并在上面使用 v-if。最终的渲染结果将不包含 template 元素。12345&lt;template v-if="ok"&gt; &lt;h1&gt;Title&lt;/h1&gt; &lt;p&gt;Paragraph 1&lt;/p&gt; &lt;p&gt;Paragraph 2&lt;/p&gt;&lt;/template&gt;用 key 管理可复用的元素Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。所以使用v-if切换input的时候已经输入的input值不会清除，所以添加一个具有唯一值的 key 属性代表这两个元素是完全独立的，不要复用它们。12345678&lt;template v-if="loginType === 'username'"&gt; &lt;label&gt;Username&lt;/label&gt; &lt;input placeholder="Enter your username" key="username-input"&gt;&lt;/template&gt;&lt;template v-else&gt; &lt;label&gt;Email&lt;/label&gt; &lt;input placeholder="Enter your email address" key="email-input"&gt;&lt;/template&gt;列表渲染v-for遍历对象1234&lt;!-- value, key, index分别代表 值, 键, 索引 --&gt;&lt;div v-for="(value, key, index) in object"&gt; &#123;&#123; index &#125;&#125;. &#123;&#123; key &#125;&#125;: &#123;&#123; value &#125;&#125;&lt;/div&gt;数组更新检测由于 JavaScript 的限制，Vue 不能检测以下变动的数组：当你利用索引直接设置一个项时，例如：vm.items[indexOfItem] = newValue当你修改数组的长度时，例如：vm.items.length = newLength1234567var vm = new Vue(&#123;data: &#123; items: ['a', 'b', 'c']&#125;&#125;)vm.items[1] = 'x' // 不是响应性的vm.items.length = 2 // 不是响应性的为了解决第一类问题，以下两种方式都可以实现和 vm.items[indexOfItem] = newValue 相同的效果，同时也将触发状态更新：Vue.set(vm.items, indexOfItem, newValue)vm.items.splice(indexOfItem, 1, newValue)为了解决第二类问题，你可以使用 splice：vm.items.splice(newLength)对象更改检测注意事项由于 JavaScript 的限制，Vue 不能检测对象属性的添加或删除：1234567891011var vm = new Vue(&#123; data: &#123; person: &#123; a: 1 &#125; &#125;&#125;)// `vm.person.a` 现在是响应式的vm.person.b = 2// `vm.person.b` 不是响应式的可以使用 vm.$set 实例方法，它只是全局 Vue.set 的别名：vm.$set(vm.person, &#39;b&#39;, 2)表单输入绑定(值绑定)复选框123456&lt;input type="checkbox" v-model="toggle" true-value="yes" false-value="no"&gt;被选中时toggle为yes, 即vm.toggle === &#39;yes&#39;, 未被选中时为no, 即vm.toggle === &#39;no&#39;单选按钮&lt;input type=&quot;radio&quot; v-model=&quot;pick&quot; v-bind:value=&quot;a&quot;&gt;即vm.pick===vm.a选择框的选项123&lt;select v-model="selected"&gt; &lt;option v-bind:value="&#123; number: 123 &#125;"&gt;123&lt;/option&gt;&lt;/select&gt;123// 当选中时typeof vm.selected // =&gt; 'object'vm.selected.number // =&gt; 123]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js选中文本和复制文本]]></title>
    <url>%2F2019%2F03%2F01%2Fjs%2Fjs%E9%80%89%E4%B8%AD%E6%96%87%E6%9C%AC%E4%B8%8E%E5%A4%8D%E5%88%B6%E6%96%87%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[Selectionvar selection = window.getSelection();selection 是一个 Selection 对象。 如果想要将 selection 转换为字符串，可通过连接一个空字符串（””）或使用 String.toString() 方法。即selection+&quot;&quot;或者selection.toString()会返回页面中选中的文本Range被选中的文字会对应一个range对象，代表选中的区域，通过window.getSelection().getRangeAt(0)代表第一个被选中的区域，也可以通过document.createRange()创建一个选中区域，range.selectNodeContents(el)将dom节点添加到range对象，selection.addRange(range)将range添加到文本选中区，selection.removeAllRanges()为取消选中的文本。执行下面的代码会选中页面的第一个p元素。12345var el = document.querySelector("p");var selection = window.getSelection();var range = document.createRange();range.selectNodeContents(el);selection.addRange(range);execCommand 方法允许运行命令来操纵可编辑内容区域的元素。bool = document.execCommand(aCommandName, aShowDefaultUI, aValueArgument);aCommandName: 一个 DOMString ，命令的名称。aShowDefaultUI: 一个 Boolean， 是否展示用户界面，一般为 false。aValueArgument: 一些命令（例如insertImage）需要额外的参数（insertImage需要提供插入image的url），默认为null。返回值bool为布尔值，如果是 false 则表示操作不被支持或未被启用，执行document.execCommand(&#39;Copy&#39;, &#39;false&#39;, null);会复制页面选中的文本示例（点击按钮复制p文本内容）123456789101112131415// 页面dom元素&lt;p&gt;aaa&lt;/p&gt;&lt;button&gt;复制&lt;/button&gt;// js代码document.querySelector("button").onclick=function() &#123; var el = document.querySelector("p"); var selection = window.getSelection(); var range = document.createRange(); range.selectNodeContents(el); selection.removeAllRanges(); selection.addRange(range); document.execCommand('Copy', 'false', null); selection.removeAllRanges();&#125;]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于layui的tree组件]]></title>
    <url>%2F2019%2F02%2F28%2Fjs%2FeleTree%2F</url>
    <content type="text"><![CDATA[因公司使用的是layui框架，而layui的树组件实现的功能太少，所以便想着自己实现一个，顺便练练手，期间因逻辑混乱代码重构过一次。插件整体思路对外仅暴漏出eleTree接口，eleTree有两个方法，on方法是layui封装的事件机制，render方法为初始化，调用render方法时，初始化树,生成实例对象thisTree为实例对象上对外的方法Class为真正的构造函数，主体结构如下：12345678910111213141516171819202122232425262728293031323334var eleTree=&#123; on: function(events, callback)&#123; return layui.onevent.call(this, MOD_NAME, events, callback); &#125;, render: function(options) &#123; var inst = new Class(options); return thisTree.call(inst); &#125;&#125;var thisTree=function() &#123; var _self=this; var options = _self.config; // 暴漏外面的方法 return &#123; append: function(key,data) &#123; if(options.data.length===0) return; return _self.append.call(_self,key,data); &#125;, // ... &#125;&#125;var Class=function(options) &#123; // ...&#125;;Class.prototype=&#123; constructor: Class, append: function(key,data) &#123; // ... &#125; // ...&#125;代码执行过程当调用var el=eleTree.render({})的时候调用Class构造函数初始化树，执行thisTree.call(inst);，即执行thisTree函数，函数内部的this为inst实例对象，然后返回一个包含多个方法的对象所以返回值el为包含多个方法的对象当调用el.append()方法时，执行inst实例对象的append方法，即执行Class原型链上的append方法，append方法内部this还是inst实例对象在线文档在线示例github源码]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>layui</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[添加图片放大效果和桃心效果]]></title>
    <url>%2F2019%2F02%2F12%2Fhexo%E9%85%8D%E7%BD%AE%2F%E5%9B%BE%E7%89%87%E6%94%BE%E5%A4%A7%E6%95%88%E6%9E%9C%E5%92%8C%E6%A1%83%E5%BF%83%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[添加图片放大效果和滚动缩放效果找到主题文件夹下的目录/source/js/src/post-details.js添加下面代码123456789101112131415161718192021222324252627282930// 图片放大$(document).ready(function() &#123; $(document.body).append('&lt;div class="lee-increase"&gt;&lt;img src=""&gt;&lt;/div&gt;'); var isShow=false; $(".post-body img").on("click",function() &#123; var src=$(this).attr("src"); var alt=$(this).attr("alt"); $(".lee-increase").show().children("img").attr("src", src).attr("alt",alt).width("auto"); $(document.body).css("overflow","hidden"); isShow=true; &#125;) $(".lee-increase").on("click",function() &#123; $(this).hide(); $(document.body).css("overflow","auto"); isShow=false; &#125;) // 鼠标滚动放大缩小 $(document).on('mousewheel DOMMouseScroll', function(e) &#123; if(!isShow) return; e.preventDefault(); var wheel = e.originalEvent.wheelDelta || -e.originalEvent.detail; var delta = Math.max(-1, Math.min(1, wheel) ); var w=$(".lee-increase img").width(); if(delta&lt;0)&#123;//向下滚动 $(".lee-increase img").width(w+50); &#125;else&#123;//向上滚动 $(".lee-increase img").width(w-50); &#125; &#125;);&#125;);找到主题文件夹下的目录/source/css/_custom/custom.styl添加下面代码1234567891011121314151617181920212223242526// 图片放大.post-body img&#123; cursor: pointer; cursor: zoom-in;&#125;.lee-increase&#123; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: #333; background-color: #333c; z-index: 99999; display: none; &amp;&gt;img&#123; max-width: 90%; min-width: 20%; position: absolute; top: 50%; left: 50%; cursor: pointer; cursor: zoom-out; transform: translate(-50%, -50%); &#125;&#125;点击出现桃心效果在post-details.js后面继续添加代码1!function(e,t,a)&#123;function n()&#123;c(".heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;"),o(),r()&#125;function r()&#123;for(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText="left:"+d[e].x+"px;top:"+d[e].y+"px;opacity:"+d[e].alpha+";transform:scale("+d[e].scale+","+d[e].scale+") rotate(45deg);background:"+d[e].color+";z-index:99999");requestAnimationFrame(r)&#125;function o()&#123;var t="function"==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e)&#123;t&amp;&amp;t(),i(e)&#125;&#125;function i(e)&#123;var a=t.createElement("div");a.className="heart",d.push(&#123;el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()&#125;),t.body.appendChild(a)&#125;function c(e)&#123;var a=t.createElement("style");a.type="text/css";try&#123;a.appendChild(t.createTextNode(e))&#125;catch(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName("head")[0].appendChild(a)&#125;function s()&#123;return"rgb("+~~(255*Math.random())+","+~~(255*Math.random())+","+~~(255*Math.random())+")"&#125;var d=[];e.requestAnimationFrame=function()&#123;return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e)&#123;setTimeout(e,1e3/60)&#125;&#125;(),n()&#125;(window,document);]]></content>
      <categories>
        <category>hexo配置</category>
      </categories>
      <tags>
        <tag>hexo图片放大</tag>
        <tag>hexo桃心效果</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义域名解析和安装SSL证书]]></title>
    <url>%2F2019%2F02%2F11%2Fhexo%E9%85%8D%E7%BD%AE%2F%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[自定义域名解析1. 申请域名我是直接在阿里云购买的.xyz为后缀的域名，阿里云域名购买。2. 添加DNS解析进入阿里云域名解析，可以看到当前购买的域名点击域名进入域名解析界面点击添加记录弹出窗口添加下图的三项记录3. 添加CNAME文件在hexo根目录的source目录新建文件，名为CNAME(无后缀名)，文件内容为域名地址，我的是hsianglee.xyz，所以在文件内直接输入hsianglee.xyz并保存。部署hexo网站hexo d -g。过几分钟之后再访问域名应该就可以了安装SSL证书，使用https访问网站1. 证书购买网址选择Symantec购买免费版购买完成后跳到SSL证书2. 申请点击申请会在右侧弹出填写完成后点击下一步点击验证之后会自动添加一条域名解析记录，然后点击下面的提交审核。审核完成之后会提示为已签发3. 添加域名解析记录在域名解析页面添加四条记录到github的博客设置里面把Enforce HTTPS 前面的checkbox选中如果无法选中，则可以删除上面的域名保存之后再重新添加域名，等几分钟之后应该就可以了然后使用https访问网站便会出现前面的锁了]]></content>
      <categories>
        <category>hexo配置</category>
      </categories>
      <tags>
        <tag>域名解析</tag>
        <tag>ssl证书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mongodb操作命令]]></title>
    <url>%2F2019%2F01%2F29%2Fmongodb%2Fmongodb%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[$set 更新或添加属性例123456789101112131415161718&#123; "_id" : 1.0, "arr" : [ &#123; "item" : "A" &#125;, &#123; "item" : "B", "score" : 4.0, "answers" : [ &#123; "q" : 1.0, "a" : 0.0 &#125; ] &#125; ]&#125;添加属性1234db.getCollection('user').update( &#123;"_id": 1.0&#125;, &#123;$set: &#123;"arr.0.score": 10&#125;&#125;)更新属性1234db.getCollection('user').update( &#123;"_id": 1.0&#125;, &#123;$set: &#123;"arr.1.score": 10&#125;&#125;)结果12345678910111213141516171819&#123; "_id" : 1.0, "arr" : [ &#123; "item" : "A", "score" : 10.0 &#125;, &#123; "item" : "B", "score" : 10.0, "answers" : [ &#123; "q" : 1.0, "a" : 0.0 &#125; ] &#125; ]&#125;$unset 删除对象的属性或把数组的其中一项变成null例1234567891011121314151617181920212223&#123; "_id" : 1.0, "arr" : [ &#123; "item" : "A", "score" : 5.5 &#125;, &#123; "item" : "B", "score" : 4.0, "answers" : [ &#123; "q" : 1.0, "a" : 0.0 &#125;, &#123; "q" : 1.0, "a" : 0.0 &#125; ] &#125; ]&#125;删除一个指定的字段12345// 删除arr数组的第一项的score属性db.getCollection('user').update( &#123;"_id": 1.0&#125;, &#123;$unset: &#123;"arr.0.score": 1&#125;&#125;)当匹配到的是数组元素，$unset替换指定的元素为null而不是删除掉指定的元素，此行为保持数组大小和位置不变；12345// 把数组arr的第二项的answers的第二项的值变为nulldb.getCollection('user').update( &#123;"_id": 1.0&#125;, &#123;$unset: &#123;"arr.1.answers.1": 1&#125;&#125;)结果12345678910111213141516171819&#123; "_id" : 1.0, "arr" : [ &#123; "item" : "A" &#125;, &#123; "item" : "B", "score" : 4.0, "answers" : [ &#123; "q" : 1.0, "a" : 0.0 &#125;, null ] &#125; ]&#125;$rename 重新命名属性名(不能操作数组)例123456&#123; "_id" : 1.0, "name" : &#123; "gge" : 18 &#125;&#125;1234db.getCollection('user').update( &#123;"_id": 1.0&#125;, &#123;$rename: &#123;"name.gge": "name.age"&#125;&#125;)结果123456&#123; "_id" : 1.0, "name" : &#123; "age" : 18 &#125;&#125;$pop 删除数组中的第一个或者最后一个元素(给$pop传递-1会删除第一个元素传递1会删除最后一个元素)例12345678910&#123; "_id" : 1.0, "arr" : [ 1, 2, 3, 4, 5 ]&#125;删除数组第一个1234db.getCollection('user').update( &#123;"_id": 1.0&#125;, &#123;$pop: &#123;"arr": -1&#125;&#125;)删除数组最后一个1234db.getCollection('user').update( &#123;"_id": 1.0&#125;, &#123;$pop: &#123;"arr": 1&#125;&#125;)结果12345678&#123; "_id" : 1.0, "arr" : [ 2, 3, 4 ]&#125;$pull 删除数组中符合条件的元素例123456789101112131415&#123; "_id" : 1.0, "arr" : [ &#123; "a": 2, "b": 5, "c": 8 &#125;, &#123; "a": 6, "b": 7, "c": 8 &#125; ]&#125;删除数组arr中的a&gt;=5的项1234db.getCollection('user').update( &#123;"_id": 1.0&#125;, &#123;$pull: &#123;"arr": &#123;"a": &#123;$gte: 5&#125;&#125;&#125;&#125;)结果12345678910&#123; "_id" : 1.0, "arr" : [ &#123; "a" : 2, "b" : 5, "c" : 8 &#125; ]&#125;使用$elemMatch匹配多个条件1234567891011121314151617181920212223242526272829&#123; "_id" : 1.0, "arr" : [ &#123; "c" : [ &#123; "a" : 10, "b" : 10 &#125;, &#123; "a" : 15, "b" : 15 &#125; ] &#125;, &#123; "c" : [ &#123; "a" : 20, "b" : 20 &#125;, &#123; "a" : 25, "b" : 25 &#125; ] &#125; ]&#125;删除arr数组 中的c数组中 (a=25 &amp;&amp; b=25)1234db.getCollection('user').update( &#123;"_id": 1.0&#125;, &#123;$pull: &#123;"arr": &#123;"c": &#123;$elemMatch: &#123;"a": 25,"b":25&#125;&#125;&#125;&#125;&#125;)结果1234567891011121314151617&#123; "_id" : 1.0, "arr" : [ &#123; "c" : [ &#123; "a" : 10, "b" : 10 &#125;, &#123; "a" : 15, "b" : 15 &#125; ] &#125; ]&#125;$push 向已有的数组末尾加入一个元素例123456&#123; "_id" : 1.0, "arr" : [ 5 ]&#125;1234db.getCollection('user').update( &#123;"_id": 1.0&#125;, &#123;$push: &#123;"arr": 10&#125;&#125;)结果1234567&#123; "_id" : 1.0, "arr" : [ 5, 10.0 ]&#125;使用$position添加到任意位置12345// 在arr数组第二项插入四项数据db.getCollection('user').update( &#123;"_id": 1.0&#125;, &#123;$push: &#123;"arr": &#123;$each: [15,16,17,18], $position: 1&#125;&#125;&#125;)结果1234567891011&#123; "_id" : 1.0, "arr" : [ 5, 15.0, 16.0, 17.0, 18.0, 10.0 ]&#125;$sort 数组排序1为升序排列，-1为降序排列12345678910&#123; "_id" : 1.0, "arr" : [ 3, 1, 5, 2, 6 ]&#125;1234db.getCollection('user').update( &#123;"_id": 1.0&#125;, &#123;$push: &#123;"arr": &#123;$each: [], $sort: 1&#125;&#125;&#125;)结果12345678910&#123; "_id" : 1.0, "arr" : [ 1, 2, 3, 5, 6 ]&#125;2. 根据数组的某一项排序12345678910111213141516171819202122232425&#123; "_id" : 1.0, "arr" : [ &#123; "a" : 5, "b" : 6 &#125;, &#123; "a" : 3, "b" : 6 &#125;, &#123; "a" : 2, "b" : 6 &#125;, &#123; "a" : 4, "b" : 6 &#125;, &#123; "a" : 5, "b" : 6 &#125; ]&#125;12345// 根据数组arr的a属性升序排列db.getCollection('user').update( &#123;"_id": 1.0&#125;, &#123;$push: &#123;"arr": &#123;$each: [], $sort: &#123;"a": 1&#125;&#125;&#125;&#125;)结果12345678910111213141516171819202122232425&#123; "_id" : 1.0, "arr" : [ &#123; "a" : 2, "b" : 6 &#125;, &#123; "a" : 3, "b" : 6 &#125;, &#123; "a" : 4, "b" : 6 &#125;, &#123; "a" : 5, "b" : 6 &#125;, &#123; "a" : 5, "b" : 6 &#125; ]&#125;$slice 数组截取正数则从前向后，负数从后向前12345678910&#123; "_id" : 1.0, "arr" : [ 1, 2, 3, 4, 5 ]&#125;12345// 截取数组arr后三位db.getCollection('user').update( &#123;"_id": 1.0&#125;, &#123;$push: &#123;"arr": &#123;$each: [], $slice: -3&#125;&#125;&#125;)结果12345678&#123; "_id" : 1.0, "arr" : [ 3, 4, 5 ]&#125;占位符$，更新数组的某一项不确定位置的值例11234&#123; "_id" : 1.0, "arr" : [ 3, 4, 5, 20 ]&#125;12345// 把数组arr值为20的变成10db.getCollection('user').update( &#123;"_id": 1.0, "arr": 20&#125;, &#123;$set: &#123;"arr.$": NumberInt(10)&#125;&#125;)结果1234&#123; "_id" : 1.0, "arr" : [ 3, 4, 5, 10 ]&#125;例21234567891011121314151617&#123; "_id" : 1.0, "arr" : [ &#123; "a" : 1, "b" : 10 &#125;, &#123; "a" : 2, "b" : 20 &#125;, &#123; "a" : 3, "b" : 30 &#125; ]&#125;12345// 更新数组arr里面属性a为2的，把当前位置的b变成200db.getCollection('user').update( &#123;"_id": 1.0, "arr.a": 2&#125;, &#123;$set: &#123;"arr.$.b": NumberInt(200)&#125;&#125;)结果1234567891011121314151617&#123; "_id" : 1.0, "arr" : [ &#123; "a" : 1, "b" : 10 &#125;, &#123; "a" : 2, "b" : 200 &#125;, &#123; "a" : 3, "b" : 30 &#125; ]&#125;]]></content>
      <categories>
        <category>mongodb</category>
      </categories>
      <tags>
        <tag>mongodb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mongodb安装]]></title>
    <url>%2F2019%2F01%2F29%2Fmongodb%2Fmongodb%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[1. 进入mongodb\bin目录 =&gt;cmd2. 在mongodb目录创建 \data\db3. cmd执行mongod.exe --dbpath=D:\mongodb\data\db4. 在mongodb目录创建 \data\log5. cmd执行 mongod.exe --logpath=D:\mongodb\data\log\mongodb.log6. 在mongodb目录创建配置文件（mongodb.config）7. 配置文件内容12dbpath=D:\mongodb\data\dblogpath=D:\mongodb\data\log\mongodb.log8. 执行 mongod.exe --config D:\mongodb\mongodb.config9. 添加到服务 （servies.msc）1mongod.exe --dbpath=D:\mongodb\data\db --logpath=D:\mongodb\data\log\log.txt --install --serviceName "MongoDB"10. 开启关闭服务123net start mongodbnet stop mongodbsc delete "MongoDB" # 删除服务]]></content>
      <categories>
        <category>mongodb</category>
      </categories>
      <tags>
        <tag>mongodb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mongodb数据导入导出]]></title>
    <url>%2F2019%2F01%2F29%2Fmongodb%2Fmongodb%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA%2F</url>
    <content type="text"><![CDATA[进入mongodb的bin目录1. 数据导出-d: 数据库名称-c: 表名-o: 存储路径–type: 导出类型-f: 导出的数据mongoexport -d test -c blog -o G:\users.json --type json -f &quot;_id,data,user&quot;2. 数据导入-d: 数据库名称-c: 表名–file: 路径–type: 导出类型mongoimport -d test -c us --file G:\users.json --type json]]></content>
      <categories>
        <category>mongodb</category>
      </categories>
      <tags>
        <tag>mongodb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mongodb加密]]></title>
    <url>%2F2019%2F01%2F29%2Fmongodb%2Fmongodb%E5%8A%A0%E5%AF%86%2F</url>
    <content type="text"><![CDATA[1. 切换到admin数据库use admin2. 管理员设置密码db.createUser({user: &quot;root&quot;,pwd: &quot;123&quot;,roles: [&quot;root&quot;]})3. 验证是否成功db.auth(&quot;root&quot;,&quot;123&quot;)4. 给其它数据库添加用户12use testdb.createUser(&#123;user: "hsianglee",pwd: "123",roles: [&#123;role: "readWrite",db: "test"&#125;]&#125;)5. mongodb.config内容修改12dbpath=F:\mongodb\data\db --authlogpath=F:\mongodb\data\log\mongodb.log6. 重启服务mongodb.exe --dbpath F:\mongodb\data\db --auth7. node连接mongodb://root:123@127.0.0.1:27017/test8. 其它命令1234db.system.users.find() # 查询已添加用户（切换到admin）db.auth("root","123") # 登录认证db.dropUser("lee") # 删除用户（先切换到当前数据库）db.updateUser("test",&#123;user: "",pwd: "", roles: [&#123;role: "read",db: "test"&#125;]&#125;) # 修改权限]]></content>
      <categories>
        <category>mongodb</category>
      </categories>
      <tags>
        <tag>mongodb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[回忆录]]></title>
    <url>%2F2017%2F10%2F09%2Fessay%2F%E5%9B%9E%E5%BF%86%E5%BD%95%2F</url>
    <content type="text"><![CDATA[相识以来九年有余，初识为汝之惊艳，汝为班长，查吾之英语。犹记之试之，吾以一纸求助于汝，汝视之弃之于娄，转而书纸助汝身后之人，时心塞之。本以与汝再无交集，却怎料初三之末，师令吾移位于汝桌之后，吾寡言，汝却擅谈，故相聊甚欢，以至于常于课传纸之于汝。未在校时，常以信聊，一日，接汝之电话，欣喜不已，然却为汝之母，以吾误汝之，批吾训吾。汝偶至吾之租舍旁，欣喜未言，因友亦喜于汝，视友与汝同食一桌，亦喜亦忧。本以为毕业之后亦无瓜葛，却于前夕于吾之抽屉视一本，字迹似汝，本上几言吾却误之，汝予吾之照片亦存于此。而后假期两月有余，常聊于扣。吾非善熬夜之人，汝却是，常聊至夜半时，然今非兮。而后至高中，同校邻班，却未敢寻汝，亦记时逢考试，汝于吾班，留一纸，主体却只一字，吾亦误之。后汝知吾常于自习之后步于操场，汝云减肥，故同步，谓吾于汝班旁候汝，亦喜。未几，汝以众口弃步，吾亦弃之。尔后愈惧汝，遇之未敢视，话之未敢答，只一笑于汝。汝以一纸信问吾何故，吾亦不知，终未答。后闻汝有友已半年有余，亦不知为何言，彻夜难眠，未敢再见。于网识一友，谓之以佳，其云乎天鹅湖边鸟飞绝，寒山寺上一棵竹，吾遂谎之删之，此为吾之错耳。倏而汝云分之，亦喜亦忧，复往昔。一日，室友知汝于桥边，怂吾寻汝，未敢，其人去往，吾亦随之，然未至之时，其先吾而跑，未曾追，不知以何谓汝，遂弃而游于河边，压抑甚久，见圆月以抒怀。然汝电话于吾，令吾往之，思虑再三终至。吾知其人助吾白于汝，或因卑，或因尊，或因不知何为恋，终未敢言丝毫。高三末时，闻人白于汝，汝拒之，甚喜甚忧。本于试后白之。后汝常寻吾，吾亦之，然至今未知汝此为何意，汝常以数学问吾，令吾送之至汝班，数日之后汝即有友，而汝友之数学胜之于吾。初视汝与汝友同于伞，入茶店，未曾信，后登汝之扣视其言语问于汝，方知晚矣。时至今汝与之分合数次，然吾亦一人也，虽偶梦汝归，知其间阂之深已非过往，期年未见早已不知汝之喜忧，终是缘而无份。又三年，闻汝已分数月而未合，虽知无果，思虑三，终白汝，虽拒终无憾。]]></content>
      <categories>
        <category>兮词</category>
      </categories>
      <tags>
        <tag>兮词</tag>
      </tags>
  </entry>
</search>
